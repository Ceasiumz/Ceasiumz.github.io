# 基于Unity 6的URP Lit.shader重构指南（2025卷王必看版）

# 写在前面
做游戏的程序员们都是很温柔很浪漫的人啊. 
图形学不妨简单理解为用逻辑在显卡上作画, 而这一切的基础就是shader language. 刚刚接触shader language的小朋友们往往会很难受, 它与其他编程语言的外观很相似, 但用到的设计方法或模式却大相径庭: 难以在declaration与usage之间跳转, 无法简单地debug...... 初学者几乎无法找到合适地工具入门图形编程.
幸好, unity6的urp(universal 渲染管线) 成为了一套非常成熟的解决方案, 可以快速让小朋友获得 `神说: "要有光"` 般的成就感, 为自己笔下(键盘下)的世界赋予光影与色彩.
所以今天, 请你跟着urp lit.shader, 一起将urp走一遭, 无论是否致力于技术美术, 这个技能都应成为每个游戏从业者的素养. 
专业名词不一一解释, 请读者自查AI.
## 一、Unity 6的URP有什么

根据Unity 6的API更新日志，重构需关注以下核心变化：

1. ​**增强型SRP Batcher**​：新增`CBUFFER_START_EX(UnityPerMaterial)`宏，支持动态材质属性分组批处理
2. ​**光线追踪扩展**​：通过`#pragma require raytracing`指令开启混合渲染管线支持(这是后话)
3. ​**Shader编译优化**​：使用`#pragma skip_variants`替代传统排除指令，减少变体生成量, 程序员的发际线有救了
4. ​**AI辅助调试**​：集成Unity Muse的实时Shader性能分析工具

我们的urp主要关注光栅化(rasterization), 可以理解为以光的辐射触发, 逐物体依次渲染, 即上色. 大家可以用这篇文章入门 [Rasterization 自行谷歌翻译](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm.html) , 当然就本文而言大家可以跳过, 我会尽量不让晦涩光栅化流程阻碍大家入门urp.
## 二、七大核心Pass重构实现

### 1. UniversalForward Pass（前向渲染）

```hlsl
// Unity 6新增Subsurface散射支持
#pragma shader_feature _SSS_PROFILE
//​SSS, 即Subsurface Scattering(次表面散射)
#pragma multi_compile_fragment _ _LIGHT_LAYERS

half4 LitPassFragment(Varyings input) : SV_Target {
    #if defined(_SSS_PROFILE)
        SurfaceData.anisotropy = GetProfileAnisotropy(input.uv);
    #endif
    
    // 集成光线追踪软阴影
    #if defined(_RAYTRACED_SHADOWS)
        ShadowData.softness = GetRaytracedShadow(input.positionWS);
    #endif
}
```

​**优化点**​：

- 采用Unity 6的`Texture2DArray.SampleLevel`实现跨平台LOD优化
- 使用`FragInputs`结构体替代传统Varyings提升寄存器利用率

### 2. GBuffer Pass（几何缓冲）

```hlsl
// 支持光线追踪GBuffer扩展
struct GBufferOutput {
    half4 GBuffer0 : SV_Target0;  // BaseColor + MaterialFlags
    half4 GBuffer1 : SV_Target1;  // Specular + Roughness
    half4 GBuffer2 : SV_Target2;  // WorldNormal + ClearCoat
    half4 GBuffer3 : SV_Target3;  // MotionVector + Depth
    #if defined(_RAYTRACING_GBUFFER)
        float4 GBuffer4 : SV_Target4; // RadianceCache
    #endif
};
```

​**技术升级**​：

- 新增Radiance Cache通道支持实时全局光照
- 采用FP16浮点精度提升HDR表现

### 3. ShadowCaster Pass（阴影投射）

```hlsl
// 支持VSM软阴影
#pragma multi_compile_shadowcaster _ _VSM_SHADOWS

Varyings ShadowPassVertex(Attributes input) {
    #if defined(_VSM_SHADOWS)
        output.variance = CalculateVariance(input.positionOS);
    #endif
}
```

​**改进点**​：

- 集成Variance Shadow Maps算法提升边缘质量
- 使用Compute Shader预计算级联阴影

### 4. DepthOnly Pass（深度预处理）

```hlsl
// 支持Nanite式分块深度压缩
#pragma enable_d3d12_workaround

half4 DepthOnlyFragment(Varyings input) : SV_TARGET {
    #if defined(UNITY_NANITE_SUPPORT)
        return PackNaniteDepth(input.clipPos.z);
    #else
        return TransformWorldToHClipDepth(input.positionWS);
    #endif
}
```

​
### 5. Meta Pass（元数据烘焙）

```hlsl
// 支持光线追踪光照贴图
#pragma require raytracing

half4 UniversalFragmentMeta(Varyings input) : SV_Target {
    #if defined(RAYTRACED_GI_BAKING)
        return RaytraceRadiosity(input);
    #else
        return TraditionalLightmapBake(input);
    #endif
}
```

### 6. DepthNormals Pass（深度法线）

```hlsl
// 支持8K超采样
#pragma enable_8k_sampling

half4 DepthNormalsFragment(Varyings input) : SV_TARGET {
    #if defined(_SUPER_SAMPLING)
        return SSAAEncode(input.normalWS);
    #else
        return PackNormalOctRectEncode(TransformWorldToViewDir(input.normalWS));
    #endif
}
```

### 7. MotionVectors Pass（运动向量）

```hlsl
// 支持光学流动预测
#pragma multi_compile _ _OPTICAL_FLOW

float4 MotionVectorPassFragment(Varyings input) : SV_Target {
    #if defined(_OPTICAL_FLOW)
        return CalculateOpticalFlow(input);
    #else
        return CalculateTraditionalMotion(input);
    #endif
}
```
