@Unity技术美术:  如何在电子游戏中实现角色-地形交互
## 引言：地形交互到底是个什么样子, 特效师搞了很多年都没有搞清楚...
地形交互在实际开发中会让制作者非常头痛: 要与玩家控制的角色实时互动, 就意味着不能使用预先制作的资产反馈玩家的行为.
周小日在游戏场景开发中就遇到了这样的苦恼: 脱离了预烘焙的场景让我很没有安全感, 随时可能溢出的资源随时可能导致运行时崩溃.
以脚印为例, 我们要根据玩家的位置实时更新地形的凹凸, 这意味着我们要实时计算地形的位置变化. 同时, 我们不能占用过多的CPU资源去计算场景. 
因此, 开发者的思路便只能往薅GPU资源的方向发展.

## Compute Shader核心技术解析

### 与传统Shader的本质区别

Compute Shader与传统渲染管线中的Vertex Shader或Pixel Shader有着根本性的不同. 它完全独立于图形渲染管线之外运行,  不参与直接的三角形变换或像素着色过程,  而是专注于通用目的的高性能计算任务. 这种独立性使得Compute Shader可以专注于纯数据处理,  不受渲染管线固有阶段的限制,  为游戏开发开辟了全新的可能性空间. 

在技术实现上,  Compute Shader通过特殊的缓冲区(如RWStructuredBuffer)和共享内存(groupshared)来管理数据,  而非传统的顶点属性或纹理采样. 这种设计使其能够处理更加复杂和多样化的数据结构. 例如,  在《荒野大镖客：救赎2》中,  开发团队使用Compute Shader同时处理场景中所有马匹的的运动力学和毛发模拟.

### 线程模型与并行架构

Compute Shader的强大性能源自GPU的高度并行架构. 一个典型的Compute Shader执行过程涉及三个层次的线程组织：线程(Thread)、线程组(Thread Group)和调度单元(Dispatch).  开发者通过[numthreads(X,  Y,  Z)]指令定义每个线程组中的线程布局,  再通过Dispatch方法指定要调度的线程组数量,  从而精确控制并行计算的规模. 

稍微深入一些( 不理解GPU线程分配的同学可以出门左转周日的GPU架构专题笔记 ),  [numthreads(64,  1,  1)]配合Dispatch(16,  1,  1)的调用将启动总计1024个线程(64×16),  非常适合处理线性缓冲区的数据. 而在处理2D纹理时,  可能会使用类似[numthreads(8,  8,  1)]的布局,  使每个线程对应纹理中的一个像素区域.

### 内存访问模式优化

高效的Compute Shader编程需要深入理解GPU的内存层次结构. 与CPU不同,  GPU拥有多种内存类型：全局设备内存、常量内存、纹理内存、共享内存和寄存器. 其中,  线程组内共享的groupshared内存是关键优化点,  它允许同一线程组内的线程快速交换数据,  避免昂贵的主内存访问. 

## 3A游戏中的经典应用案例

### 动态雪地与地形变形

《古墓丽影：崛起》和《地平线：黎明时分》等游戏展示了Compute Shader在动态雪地模拟中的惊人能力. 这些实现通常基于"变形高度图"技术,  使用Compute Shader实时更新表示雪地高度的纹理. 

技术实现上,  游戏会为每个可能影响雪地的物体(如角色脚步)定义"变形点"(Deformation Points). Compute Shader将这些点的位置信息转换为高度图上的修改,  同时计算两种关键效果：Trail depression(脚印凹陷)和Trail elevation(边缘隆起). 为实现自然效果,  开发团队还实现了"填充Shader"(Fill Shader),  模拟暴风雪逐渐填平脚印的过程,  大大增强了环境的真实感. 

一个关键技术挑战是处理动态捕捉区域与纹理分辨率的关系. 早期实现使用固定大小的捕捉区域,  导致纹理内存浪费和精度不足. 现代解决方案采用动态跟随的捕捉空间,  只在角色周围的高交互区域分配高分辨率纹理,  显著提高了资源利用率.

当然, 动态跟随会导致其他问题, 譬如开发者必须限制玩家的视野, 尽量让玩家察觉不到突兀的场景更新. 周小日在玩黑猴的时候就发现雪地上的脚印会定时更新. 猕猴友们下次在打杀杨戬的闲暇时刻不妨细细观察一番.

### 大规模粒子系统

《战神4》和《堡垒之夜》等游戏利用Compute Shader实现了令人叹为观止的粒子效果,  包括暴风雪、魔法特效和爆炸等. 与传统CPU处理的粒子系统相比,  GPU驱动的粒子可以实现数量级更多的粒子计数(数十万甚至数百万),  同时保持极高的渲染效率. 

Compute Shader在这种应用中的优势在于能够并行更新所有粒子的物理状态. 每个粒子可以分配一个独立的线程,  同步计算位置、速度、生命周期等属性. 在《战神4》中,  开发团队还将粒子与Compute Shader生成的速度场结合,  实现了雪粒随风飘扬、在角色周围环绕等效果.

### 高级光照与阴影计算

现代3A游戏的光照系统越来越依赖Compute Shader进行复杂计算. 光线追踪虽然是热门话题,  但在大多数实时场景中,  基于Compute Shader的混合光照方案仍占据主导地位. 

《地平线：黎明时分》使用Compute Shader进行全局光照探针的实时更新,  结合距离场阴影技术,  实现了动态物体与环境的逼真光照交互. 这种技术允许游戏世界中的每一个物体都能正确反射周围环境的光照,  包括动态变化的天气和时间条件. 

特别值得一提的是,  许多游戏现在使用Compute Shader进行屏幕空间反射(Screen Space Reflection)的计算,  相比传统方法,  这种方式可以更高效地处理反射模糊和粗糙表面反射等光照遮蔽效果. 

### 流体与布料模拟

《荒野大镖客：救赎2》中惊艳的河流、湖泊和马匹毛发效果,  很大程度上归功于基于Compute Shader的流体模拟系统. 这类模拟通常采用基于网格的方法,  将流体域划分为规则的网格,  每个网格单元存储速度、密度和压力等物理量. 

Compute Shader并行处理所有网格单元,  执行压缩解算(Project)、流动(Advect)和扩散(Diffuse)等物理计算步骤. 在《大鏢客2》的实现中,  开发团队还加入了基于距离场的障碍物处理,  使流体能够与复杂地形自然交互,  产生逼真的波浪和漩涡效果. 

布料模拟同样受益于Compute Shader的并行能力. 传统CPU布料模拟通常只能处理少量高细节服装,  而GPU加速的方案可以同时模拟数十个角色的服装动态,  包括复杂的风场交互和自碰撞检测. 这在《刺客信條》系列等拥有大量NPC群集的游戏中尤为重要. 

## Unity中的实现方法

### 基本结构与工作流程

在Unity中实现Compute Shader需要同时处理两个关键部分：Compute Shader文件(.compute)和调用它的C#脚本. Compute Shader文件使用HLSL语言编写,  包含一个或多个计算内核(Kernel),  每个内核代表一个可并行执行的计算任务. 

一个典型的Compute Shader结构如下：

```cs
#pragma kernel KernelName

RWStructuredBuffer<float> dataBuffer;
groupshared float tempData[128];

[numthreads(64,  1,  1)]
void KernelName(uint3 id : SV_DispatchThreadID)
{
    // 并行计算逻辑
    dataBuffer[id.x] *= 2.0f;
}
```

C#脚本负责初始化数据缓冲区、调用Compute Shader并获取结果：

```cs
public ComputeShader computeShader;
ComputeBuffer dataBuffer;

void Start() {
    // 初始化缓冲区
    dataBuffer = new ComputeBuffer(1024,   sizeof(float));
    float[] inputData = new float[1024];
    dataBuffer.SetData(inputData);
    
    // 调用Compute Shader
    int kernel = computeShader.FindKernel("KernelName");
    computeShader.SetBuffer(kernel,   "dataBuffer",   dataBuffer);
    computeShader.Dispatch(kernel,   16,   1,   1); // 16组×64线程=1024总线程
    
    // 获取结果
    float[] outputData = new float[1024];
    dataBuffer.GetData(outputData);
    dataBuffer.Release();
}
```

### 纹理处理技术

除了结构化缓冲区,  Compute Shader还可以直接读写纹理数据,  这使其成为图像处理的理想选择[4](https://tencent.yuanbao/@ref). Unity中使用RWTexture2D类型声明可读写纹理,  结合RenderTexture实现高效的图像处理流水线. 

一个图像变灰的示例：

```cs
#pragma kernel CSMain
Texture2D<float4> inputTex;
RWTexture2D<float4> outputTex;

[numthreads(8,  8,  1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float4 color = inputTex[id.xy];
    float gray = dot(color.rgb,   float3(0.299,   0.587,   0.114));
    outputTex[id.xy] = float4(gray,   gray,   gray,   color.a);
}
```

C#中的调用方式：

```cs
RenderTexture inputRT = ...; // 输入纹理
RenderTexture outputRT = ...; // 输出纹理

int kernel = computeShader.FindKernel("CSMain");
computeShader.SetTexture(kernel,   "inputTex",   inputRT);
computeShader.SetTexture(kernel,   "outputTex",   outputRT);
computeShader.Dispatch(kernel,   Mathf.CeilToInt(width/8f),   Mathf.CeilToInt(height/8f),   1);
```

这种技术广泛应用于后处理效果、动态贴图生成和GPU粒子渲染等场景. 

### 与渲染管线的交互

Compute Shader的强大之处在于其计算结果可以无缝传递到渲染管线. 通过共享缓冲区或纹理,  Compute Shader可以预处理几何数据、生成实例化参数或计算高级光照信息,  供后续渲染阶段使用.

在URP/HDRP管线中,  这种集成更加紧密. 聊举一例,  可以在渲染前使用Compute Shader执行视锥体裁切,  生成GPU实例化所需的参数缓冲区,  大幅减少CPU-GPU数据传输和Draw Call数量. 现代Unity项目还常用Compute Shader生成地形补丁数据或细分参数,  实现动态LOD和流式加载. 


## 资源

一些权威的文档, 推荐用于自学(~~爽抄~~)

1. ​**官方文档**​：参考来自Unity Compute Shader官方之最权威(吗?) [手册和API参考](https://docs.unity3d.com/6000.2/Documentation/Manual/class-ComputeShader-introduction.html)
    
2. ​**开源项目**​：研究GitHub上的开源实现,  如Blit和Fullscreenshader的映射[这个是真神](https://github.com/Cyanilux/URP_BlitRenderFeature)
	

---
**宝宝你是一个香香软软的小Warning, 不要忘记点赞加关注o**

参考视频: 
[最简单的应用，让你了解ComputeShader](https://www.bilibili.com/video/BV1EPXJY4EUo/?share_source=copy_web&vd_source=3a619032bfaebcd13ed71a5a670e460d)
[URP Cookbook: Compute shaders - Part 1: Particle fun](https://youtu.be/omZap7XHxKc?si=jvisVOMRS2yFugUX)
